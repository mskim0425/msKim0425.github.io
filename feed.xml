<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://mskim0425.github.io/</id><title>SoThoughtful;</title><subtitle>백엔드 개발자의 정리글, java, spring stuff</subtitle> <updated>2025-02-16T18:47:39+09:00</updated> <author> <name>Minsub Kim</name> <uri>https://mskim0425.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://mskim0425.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://mskim0425.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2025 Minsub Kim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Ruby on Rails Exception 그리고 트랜잭션</title><link href="https://mskim0425.github.io/posts/exception_rails/" rel="alternate" type="text/html" title="Ruby on Rails Exception 그리고 트랜잭션" /><published>2025-02-16T11:40:00+09:00</published> <updated>2025-02-16T11:40:00+09:00</updated> <id>https://mskim0425.github.io/posts/exception_rails/</id> <content src="https://mskim0425.github.io/posts/exception_rails/" /> <author> <name>Minsub Kim</name> </author> <category term="Web Development" /> <category term="Performance Optimization" /> <summary> 예외처리 프로그램 실행중에 발생할 수 있는 예외를 처리하고 무엇보다 중단되지않도록 사용하는 기법이다. 루비에서의 예외처리 기본구조는 아래와같다. begin # 예외가 발생할 수 있는 코드 rescue Exception =&amp;gt; e # 예외가 발생했을 때 처리할 코드 else # 예외가 발생하지 않았을 때 실행할 코드 ensure # 항상 실행되는 코드 end # 커스텀 기본적인 예외처리 구조 def controller # 작동 raise '에러메시지' if problem? # 비즈니스 로직상 예외처리 rescue Exception -&amp;gt; e #작동중 에러가 터지면 여기로 작동되게 함 end rescue_from rescue_from는 Ruby on Rails에서 Cont... </summary> </entry> <entry><title>Ruby on Rails 성능 최적화: 레일즈 캐싱</title><link href="https://mskim0425.github.io/posts/rails_cache/" rel="alternate" type="text/html" title="Ruby on Rails 성능 최적화: 레일즈 캐싱" /><published>2025-01-25T19:40:00+09:00</published> <updated>2025-01-25T19:40:00+09:00</updated> <id>https://mskim0425.github.io/posts/rails_cache/</id> <content src="https://mskim0425.github.io/posts/rails_cache/" /> <author> <name>Minsub Kim</name> </author> <category term="Web Development" /> <category term="Performance Optimization" /> <summary> Rails에서 제공하는 캐싱(Caching)은 웹 애플리케이션의 성능을 향상시키기 위해 자주 사용되는 데이터나 결과를 저장하여 불필요한 데이터베이스 호출이나 복잡한 연산을 줄이는 기술이다. Rails는 다양한 캐싱 메커니즘을 제공하며, 각각의 용도와 특징이 있다. 1. Page Caching 페이지 캐싱은 컨트롤러 액션의 전체 HTML 출력을 정적 HTML 파일로 저장하여 처리 속도를 높이는 방식이다. 이 방식은 인증이 필요 없는 정적 페이지에 적합하다. 동적 컨텐츠에는 부적합해보인다. ex class ProductsController &amp;lt; ActionController::Base caches_page :index def index @products = Product.all ... </summary> </entry> <entry><title>Ruby on Rails 성능 최적화: 가비지 컬렉션</title><link href="https://mskim0425.github.io/posts/rails_gc/" rel="alternate" type="text/html" title="Ruby on Rails 성능 최적화: 가비지 컬렉션" /><published>2025-01-19T19:40:00+09:00</published> <updated>2025-01-19T19:40:00+09:00</updated> <id>https://mskim0425.github.io/posts/rails_gc/</id> <content src="https://mskim0425.github.io/posts/rails_gc/" /> <author> <name>Minsub Kim</name> </author> <category term="Web Development" /> <category term="Performance Optimization" /> <summary> 정리하게된 계기 Rails App 경우 자바와 같이 object가 생성될떄 힙에 실제데이터를 올리고 있는데 메모리를 해제를 어떻게하는지 궁금해서 찾아보게 되었다. Ruby의 가비지 컬렉션(GC) 메커니즘은 메모리 관리의 핵심 부분이다. GC 모듈을 통해 이 과정을 이해하고 최적화할 수 있다. Rails 애플리케이션에서 메모리 사용량이 높아지는 주요 원인 중 하나는 객체 보유이다. (전부 다 객체화 하기때문인듯) 수명이 짧은 객체(Short-Lived Objects) 보통의 루비 객체는 짧은 생명 주기를 가진다: User.where(name: "kms") ORM 쿼리 실행 시 여러 객체가 생성된다 (예: where 메서드, :name 심볼, "kms" 문자열). 쿼리 실... </summary> </entry> <entry><title>비슷하면서 다른 SQL 정리</title><link href="https://mskim0425.github.io/posts/groupby_-partition/" rel="alternate" type="text/html" title="비슷하면서 다른 SQL 정리" /><published>2025-01-14T19:40:00+09:00</published> <updated>2025-01-14T19:40:00+09:00</updated> <id>https://mskim0425.github.io/posts/groupby_-partition/</id> <content src="https://mskim0425.github.io/posts/groupby_-partition/" /> <author> <name>Minsub Kim</name> </author> <category term="PARTITION" /> <category term="GROUP" /> <summary> GROUP BY와 PARTITION BY GROUP BY와 PARTITION BY는 SQL에서 데이터를 그룹화하는 데 사용되는 중요한 구문이다. 두 구문은 유사한 기능을 하지만, 결과 데이터의 구조와 사용 목적에 차이가 있다. 주요 차이점 특성 GROUP BY PARTITION BY 결과 행의 수 그룹화된 결과만 반환하여 감소 모든 원본 행 유지 데이터 집계 방식 그룹별로 집계하여 하나의 결과 행 생성 각 행에 그룹의 집계 결과 추가 사용 위치 SELECT 문의 마지막 부분 윈도우 ... </summary> </entry> <entry><title>가상테이블</title><link href="https://mskim0425.github.io/posts/virtual_table/" rel="alternate" type="text/html" title="가상테이블" /><published>2024-12-28T09:40:00+09:00</published> <updated>2024-12-28T09:40:00+09:00</updated> <id>https://mskim0425.github.io/posts/virtual_table/</id> <content src="https://mskim0425.github.io/posts/virtual_table/" /> <author> <name>Minsub Kim</name> </author> <category term="virtual_table" /> <summary> MySQL에서 가상 테이블은 실제 데이터를 저장하지 않고 쿼리 결과를 임시로 저장하는 객체아다. 가상 테이블의 주요 형태로는 View, 파생 테이블(Derived Table), CTE(Common Table Expression), Temporary Table이 있다. 1. 뷰(View) 뷰는 하나 이상의 테이블에서 원하는 데이터를 선택하여 만든 가상 테이블이다. 뷰는 데이터베이스에 저장되며, 재사용이 가능하다. 특징: 실제 데이터를 저장하지 않고, 쿼리 정의만 저장한다. 기본 테이블의 데이터가 변경되면 뷰의 데이터도 자동으로 변경된다. 복잡한 쿼리를 단순화할 수 있다. 예시: -- 뷰 생성 CREATE VIEW high_salary_employees AS SELECT em... </summary> </entry> </feed>
