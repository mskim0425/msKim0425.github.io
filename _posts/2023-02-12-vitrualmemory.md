---
layout: post
title:  "OS - Memory"
date:   2023-02-12 11:01:04 +0900
categories: [CS, memory]
tags: [cs, memory]
---

## OS 정리

#### 운영체제의 역할  
1. CPU 스케줄링과 프로세스 관리 (CPU 소유권을 얼마만큼 할장할지, 프로세스의 생성과 삭제 할당을 관리, 반환함.)
2. 메모리 관리 (한정된 메모리를 어떤 프로세스가 관리할지 할당)
3. 디스크 파일 관리 
4. I/O 디바이스 관리 (키보드 마우스의 데이터 주고받음)

이렇게 크게 4가지가있다. 하드웨어와 USER 프로그램 사이에 존재하여 해당 역할들을 수행한다.  
하드웨어 ->  `드라이버, 커널, 시스템콜, GUI or CUI` -> USER program

##### GUI or CUI  
CUI는 명령줄 인터페이스로써 도스, CMD, bash를 뜻하는 환경이다.  
GUI 여기서 좀 더 발달해서 그래픽으로 제어하고 볼 수 있는 환경을 GUI라고 한다.

##### 시스템콜  

OS가 커널에 접근하기 위한 인터페이스이면서 유저 프로그램이 OS의 서비스를 받기 위해 커널 함수를 호출할 때 사용한다.  
USER PROGRAM이 입/출력을 요청 시, 올바른 요청인지 확인하고 유저 lv이 시스템콜을 통해 커널lv로 변환되어 실행된다.  
쉽게말해 하나의 추상화 계층으로써, 유저모드의 파일을 그대로 읽는 것이 아닌 시스템 콜을 통해 커널lv로 진입하여 파일을 읽거나 수정하거나 한다. 이런 점은 직접적인 접근을 차단하고 프로그램을 다른 프로그램으로부터 지킬 수 있다.  

<img src="https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2F3fe1b842-a2e9-4056-b266-f9c034226bd5%2Fimage.png">  

> `유저lv` : 유저가 접근할 수 있는 영역을 제한적으로 두어 컴퓨터 자원의 무분별한 진입을 막는 모드  
> `커널lv`: 모든 컴퓨터 자원을 접근할 수 있는 모드  
> `커널`: OS의 핵심 부분이면서 시스템콜 인터페이스를 제공하며 보안부터 메모리, 프로세스 File 시스템 등 OS의 중추적인 역할을함.  
{: .prompt-tip}

##### 드라이버

OS와 디바이스가 서로 통신할 수 있는 sw 구성요소. 보통 마우스나 컴퓨터의 I/O를 담당하는 디바이스에 이런 드라이버를 설치하는 경우가 종종있는데 이는 드라이버를 통해 데이터를 가져오거나 입력받은 데이터를 OS가 이해할 수 있도록 변환 시켜주는 역할을 한다고 보면된다.  

---

### CPU + RAM 사이  

메모리에 내용을 얘기하기 전, 메모리 앞단에서 일어나는 일에 대해 알필요가 있다. CPU에 해당되는 캐시와 레지스트리인데 둘의 기능과 차이에 대해 알아보자.  

<img src="https://melonicedlatte.com/system/uploads/images/000/001/482/original/image.png?1541583910">

`레지스터`란 CPU안에 있는 작은 메모리로써 작은 메모리와 휘발성을 가지고 있으며 용량도 매우 적다. 일반적으로는 현재 계산을 수행중인 값을 저장하는데 사용된다.  

`캐시 메모리`란, 속도가 빠른 장치(CPU)와 느린 장치(RAM) 사이에서 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리를 지칭한다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 다시 계산하는 시간을 절약할 수 있는 것이다.  

> 이 둘은 어떤 명령어나 데이터를 저장하는 공간이지만, 캐시는 CPU에 별도 공간이 있고 메모리와 CPU의 속도차이의 버퍼같은 존재이고 레지스터는 CPU 내에서 연산을 처리하기 위한 데이터 저장공간이다.
{: .prompt-tip}

##### 메모리 관리

OS의 대표적인 일 중의 하나인 컴퓨터 내의 한정된 메모리 자원을 극한으로 활용하는 것이다. 그 중 극한으로 사용하는 방법 중 하나인 가상메모리에 대해 알아보자.  
 
`가상메모리란?` 메모리 관리 기법으로 하나로 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화하여 이를 USER에게는 큰 메모리로 보이게하는 방법이다. 그러기 위해선 가상 주소와 실제주소를 연결하는 PAGE TABLE이 있어야한다.   

<img src="https://github.com/mskim0425/mskim0425.github.io/blob/main/images/cs/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC.png?raw=true">

##### PAGE TABLE이란?  
`page table은 위와같이 가상주소와 실제 주소를 mapping하는 테이블이다`. 메인 메모리에 존재하며 프로세스마다 고유의 page table을 가진다. context switching(프로세스를 교체) 할 때마다 page table도 변경돼야 한다. 즉, CPU가 어느 page table을 사용할지 알아야 한다.  
그림처럼 page table는 메인 메모리에 존재한다. CPU는 명령어를 수행하기 위해서 메인 메모리에 최소 2번은 접근해야 원하는 데이터를 얻을 수 있다. 이는 명령어 하나하나에 같은 table이어도 메인메모리에 접근해야하는 불필요한 상황이 연출된다. 이러한 접근을 줄이고자 나온 개념이 Traslation Look-aside Buffer (TLB)이다.  


<img src="https://blog.kakaocdn.net/dn/eg79xp/btqzjf5pSyX/1DKIZo5kpikuRFhlKor1yk/img.jpg">

##### TLB이란?  
메모리와 cpu 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하며 cpu가 페이지 테이블까지 가지않도록 관리하여 속도를 향상시킬 수 있는 캐시 계층이다. 쉽게 말해 page table의 캐시 역할을 한다.  

TLB에 정보가 없을떈 TLB miss라고 하는데 2가지 상황으로 나뉜다.  
`TLB에는 없지만 Main 메모리에 있을 경우`: Page table을 가져와서 (physical memory) 위 그림의 TLB에 저장하면 된다.  

`Page Fault` = 요청한 page가 Main 메모리에도 없는 경우 :  이떄는 하드디스크로 부터 데이터를 불러와 TLB에 저장할 수 있고 Main 메모리에서 불러오는 속도에 비해 10000배정도의 차이가 있다고 한다.  

Page Fault로 스와핑하는 케이스

1. CPU는 물리메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 OS에 알린다.  
2. OS는 CPU 동작을 잠시 멈춤
3. OS는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 화깅ㄴ하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어있는 공간이 찾는다. 그 조차도 없으면 스와핑이 발동된다.

>`스와핑`  
> 메모리에서 당장 사용하지않는 영역을 하드디스크로 옮기고 디스크의 일부분을 마치 메모처럼 불러와 사용하는 행동  

4. 비어있는 공간에 해당 페이지를 로드하고 Page table을 업데이트한다.  
5. 중단했던 CPU가 다시 시작한다. 
  
