---
layout: post
title:  "Algorithm just for memo"
date:   2023-01-19 13:11:04 +0900
categories: [Java, Algorithm]
tags: [java, algorithm]
---

## 결정알고리즘

결정 알고리즘의 핵심은 lp 처음 시작점과 rp 끝지점의 설정  
while문안에서 lp와 rp가 만나서 lp와 rp의 이동을 어찌할지에 따라 달렸다.  
비교 시, 메서드를 하나 추가해 검증로직을 짜는 식으로 구현한다.  

```java
public class Main{
    private static void solution(int horse, int house, int[] arr) {
        Arrays.sort(arr); //정렬하고
        int lp = 1; //1
        int rp = arr[house-1]; //9
        int answer = 0;
        while (lp <= rp){
            int mid = (lp + rp) / 2; //5 간격 예시
            if(testing(arr,mid) >= horse) {
                answer = mid;
                lp = mid + 1;
            }
            else
                rp = mid - 1;

        }
        System.out.println(answer);
    }

    private static int testing(int[] arr, int mid) {
        int pointer = arr[0];
        int counter = 1;
        for (int i = 1; i < arr.length; i++) {
            if(pointer + mid <= arr[i]) {
                counter++;
                pointer = arr[i];
            }
        }
        return counter;
    }

}
```

## 메모이제이션
5C3 조합문제를 구할때 공식은 4C2 + 4C3이다.  
이런식으로 3C1+ 3C2 + 3C2 + 3C3 쭉쭉 재귀를 타면~ 해당값이 구해지는데 문제는 33C19 이런식의 데이터를 구할때 엄청나게 메모리소모와 시간이 소요되므로 `메모이제이션` 을 이용해서 미리 계산한 값은 계산하지 않는 방식으로 진행하는 테크닉이다.
```java
public class Main {

    int[][] memo = new int[35][35]; //메모이제이션
    public static void main(String[] args) {
        Main m = new Main();
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        int j = sc.nextInt();
        System.out.println(m.dfs(i, j));
    }

    private int dfs(int i, int j) {
        if(memo[i][j]>0) return memo[i][j]; //해당 구한 값을 수행했느냐?
        if(j==0 || i==j) return 1;
        else return memo[i][j] = dfs(i-1, j-1) + dfs(i-1, j); //값을 기록하고 리턴하는 방법
    }
}
```

